% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/naiveBayes.R
\name{update.nb2}
\alias{update.nb2}
\title{Update Naive Bayes Classifier with New Data}
\usage{
\method{update}{nb2}(object, newdata, y, ...)
}
\arguments{
\item{object}{[nb2]
Naive Bayes model to be updated.}

\item{newdata}{[data.frame]
Data.frame with same column names as in object.}

\item{y}{[factor | numeric | character]
Class vector.}

\item{...}{Arguments passed to \code{\link{nb2}()}.}
}
\description{
Update Naive Bayes Classifier with New Data
}
\examples{
data = data.frame(x1 = 1:10, x2 = 1:10)
class = factor(rep(1:2, each = 5))
(object = nb2(data, class))
newdata = data.frame(x1 = 11:14, x2 = 11:14)
y = factor(rep(1:2, each = 2))
update(object, newdata, y)

data = data.frame(x1 = 1:10, x2 = 1:10)
class = factor(rep(1, 10))
(object = nb2(data, class))
newdata = data.frame(x1 = 11:14, x2 = 11:14)
y = factor(rep(1:2, each = 2))
update(object, newdata, y)

\dontrun{
set.seed(1909)
dat = mlbench::mlbench.smiley(500)
obj = nb2(x = dat$x[1:100, ], y = dat$classes[1:100])
plot(obj, xlim = c(-2, 2), ylim = c(-2, 2), gg = FALSE)
i = j = 101
while (i < nrow(dat$x)) {
  j = min(j + max(rpois(1, 10), 2), nrow(dat$x))
  newd = dat$x[i:j, ]
  newc = dat$classes[i:j]
  obj = update(obj, newd, newc)
  cat(i, j)
  print(all.equal(obj, nb2(dat$x[1:j, ], dat$classes[1:j]),
                  check.attributes = FALSE, check.names = FALSE))
  plot(obj, xlim = c(-2, 2), ylim = c(-2, 2), gridsize = 50, gg = FALSE)
  points(dat$x[1:j, ], col = dat$classes[1:j], pch = 4, lwd = 4)
  BBmisc::pause()
  i = j + 1
}
all.equal(obj, nb2(dat$x, dat$classes), check.attributes = FALSE, check.names = FALSE)
}


### mixed attributes:
set.seed(1909)
daten <- mlbench::mlbench.2dnormals(1000)
daten$x <- data.frame(daten$x, X3 = factor(as.numeric(daten$classes) + rbinom(1000, 1, 0.2)))
plot(daten)

mod1 <- nb2(daten$x[, 1:2], daten$classes)
preds1 <- predict(mod1, daten$x[, 1:2])
mean(preds1 != daten$classes)

mod2 <- nb2(daten$x, daten$classes)
preds2 <- predict(mod2, daten$x)
mean(preds2 != daten$classes)

k <- sample(1:1000, 100)
newdata <- daten$x[k, ]
y <- daten$classes[k]

all.equal(update(mod2, newdata, y), nb2(rbind(daten$x, newdata), c(daten$classes, y)),
          check.attributes = FALSE, check.names = FALSE)


iris.disc <- iris[, 1:4]
discParam <- list(Sepal.Length = c(5, 6, 7), Sepal.Width = c(2.5, 3.5))
iris.disc[, 1:2] <- sapply(names(discParam), simplify = FALSE, function(x)
  cut(iris[, x], breaks = unique(c(Inf, -Inf, discParam[[x]]))))
mod.disc1 <- nb2(iris.disc[, 1:4], iris[, 5])

mod.disc2 <- nb2(iris[, 1:4], iris[, 5], discretize = "fixed", discParam = discParam)

all.equal(mod.disc1, mod.disc2)

plot(mod.disc1)
plot(mod.disc2, xlim = c(4, 8), ylim = c(1.5, 4.5))
plot(mod.disc1, features = c(1, 3))
plot(mod.disc2, xlim = c(4, 8), features = c(1, 3))


k <- sample(nrow(iris), 10)
newdata1 <- iris.disc[k, 1:4]
newdata2 <- iris[k, 1:4]
y <- iris[k, 5]

upd1 <- update(mod.disc1, newdata1, y)
upd2 <- update(mod.disc2, newdata2, y)
all.equal(upd1, upd2)

}

